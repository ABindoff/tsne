---
title: "Manifold dimension reduction"
author: "Bindoff, A."
date: "31 October 2017"
output: html_document
---

```{r setup, include=FALSE}
library(knitr)
library(rgl)
library(Rtsne)
library(ggplot2)
library(geozoo)
knitr::opts_chunk$set(echo = FALSE)
knit_hooks$set(webgl = hook_webgl)
n <- 3000
```

`r n` points are sampled randomly and uniformly from the surface of a torus. We wish to make a 2 dimensional representation of these points such that local structure is preserved, *i.e.* points that are close together should stay together. We colour the points to give a sense of where they belong.  


```{r, webgl = TRUE, warning = F, message = F, hold = T}


X <- torus(p = 3, n = n, radius = c(3,1))
A <- data.frame(X$points)
names(A) <- c("v1", "v2", "v3")
A$v4 <- round(((A$v3+1)/2)*n,0)
A <- dplyr::arrange(A, v3)

cr <- colorRampPalette(c("white", "wheat", "yellow", "coral", "firebrick", "black"))(n)

with(A, plot3d(v1, v2, v3, type = "s", size = 1, col = cr[v4], aspect = FALSE))
```

The Barnes-Hut t-SNE algorithm attempts to fit a model with fewer dimensions, preserving local structure. The lower-dimensional model looks a lot like an elastic torus was split open and flattened out, kind of like a popped torus-shaped balloon.  


```{r, webgl = TRUE}
m1 <- Rtsne(as.matrix(scale(A[,1:3])), dims = 2, initial_dims = 3, perplexity = 200, verbose = F)
B <- data.frame(m1$Y)
B$v4 <- A$v4
B$v4[B$v4 == 0] <- 1
B$col <- cr[B$v4]
B$v3 <- rnorm(n, 0, 0.1)

with(B, plot3d(X1, v3, X2, type = "s", size = 1, col = cr[v4], aspect = FALSE))
# 
# ggplot(B, aes(x = X1, y = X2, colour = factor(v4))) +
#   geom_point(size = 1) + scale_color_manual(guide = F, values = cr)
```


A fourth dimension is added that has a linear relationship with another dimension (v3 on the plot). We simply add the colour mapping as a fourth dimension, and see if we recover the 3 dimensional structure with the colour mapping in-tact. The columns of the 4 x `r n` matrix have been scaled.  


```{r, webgl = TRUE}

m1 <- Rtsne(as.matrix(scale(A)), dims = 3, initial_dims = 4, perplexity = 400, verbose = F, max_iter = 1200)
B <- data.frame(m1$Y)
B$v4 <- A$v4
B$v4[B$v4 == 0] <- 1
B$col <- cr[B$v4]
B$v3 <- rnorm(n, 0, 0.1)

with(B, plot3d(X1, X2, X3, type = "s", size = 1, col = cr[v4], aspect = FALSE))

```

Again, this looks like a torus-shaped balloon has been burst, only in this case it hasn't been flattened out. Note the characteristic effect of Barnes-Hut pulling clusters together. The `perplexity` hyperparameter controls the degree to which this occurs. The objective function of the gradient descent algorithm is to minimise Kullback-Leibler divergence, however the solution space is non-convex so the optimal solution isn't guaranteed. Nevertheless this is a fair representation of the original 4d object. If the matrix hadn't been scaled, the dimension represented by colour would have dominated under Kullback-Leibler as we will see below,  

```{r, webgl = TRUE}

m1 <- Rtsne(as.matrix(A), dims = 3, initial_dims = 4, perplexity = 200, verbose = F, max_iter = 1200)
B <- data.frame(m1$Y)
B$v4 <- A$v4
B$v4[B$v4 == 0] <- 1
B$col <- cr[B$v4]
B$v3 <- rnorm(n, 0, 0.1)

with(B, plot3d(X1, X2, X3, type = "s", size = 1, col = cr[v4], aspect = FALSE))

```

Sure it's pretty, but it doesn't tell us much about v1, v2, or v3.  

To increase the level of difficulty, all linear relationships are removed. Now the fourth dimension has a non-linear relationship with v3 and no correlation with v2 or v1.  


```{r, webgl = TRUE}
A$v4 <- round(abs(A$v3)*n, 0)
with(A, plot3d(v1, v2, v3, type = "s", size = 1, col = cr[v4], aspect = FALSE))
```


```{r, webgl = TRUE}
m1 <- Rtsne(as.matrix(scale(A)), dims = 3, initial_dims = 4, perplexity = 200, verbose = F)
B <- data.frame(m1$Y)
B$v4 <- A$v4
with(B, plot3d(X1, X2, X3, type = "s", size = 1,  col = cr[v4]))
```


Add dimension v5 which has a non-linear relationship to v1, v2 & v3, and a linear relationship with v4. 



```{r, webgl = TRUE}
A$v5 <- (A$v1)^3
with(A, plot3d(v1, v2, v5, type = "s", size = 1, col = cr[v4]))
with(A, plot3d(v2, v3, v5, type = "s", size = 1, col = cr[v4]))
with(A, plot3d(v1, v4, v5, type = "s", size = 1, col = cr[v4]))

```

Add dimension v6 which gets weird fast.


```{r, webgl = TRUE, echo = T}
A$v6 <- (A$v2)^2 + sqrt((A$v5-A$v3)^2)
with(A, plot3d(v2, v6, v5, type = "s", size = 1, col = cr[v4]))
with(A, plot3d(v3, v5, v6, type = "s", size = 1, col = cr[v4]))

```

We're up to 6 dimensions, so feasibly we could explore them by looking at every combination (here's another representation by way of example)   

```{r, webgl = TRUE}
with(A, plot3d(v4, v1, v6, type = "s", size = 1, col = cr[v4]))
```

But for every dimension we add, we have *d choose 3* possible spatial representations. If we have 10 dimensions, that's 120 (or d-1 choose 3 = 84 if we use colour).  

Setting `perplexity` = 750, the algorithm will take a long time to compute the embeddings, but the result is superb. If you take some time to explore all of the plots above, you will see that those shapes are embedded in the dimension-reduced t-SNE plot.  


```{r, webgl = TRUE}
m2 <- Rtsne(as.matrix(scale(A)), dims = 3, initial_dims = 6, perplexity = 750)
B <- data.frame(m2$Y)
B$v4 <- A$v4
# load("dimension_reduction.RData")
with(B, plot3d(X1, X2, X3, type = "s", size = 1,  col = cr[v4]))
```